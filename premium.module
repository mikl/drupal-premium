<?php
/**
 * @file Restrict access to the full body of premium content
 */

/**
 * Implementation of hook_menu()
 */
function premium_menu() {
  $items = array();

  $items['admin/content/premium'] = array(
    'title' => t('Premium content'),
    'description' => t('Settings for access control to premium content.'),
    'page callback' => 'premium_admin_overview_page',
    'access arguments' => array('administer premium content levels'),
    'file' => 'premium.admin.inc',
  );

  $items['admin/content/premium/overview'] = array(
    'title' => t('Overview'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => '-10',
  );

  $items['admin/content/premium/add'] = array(
    'title' => t('Add premium level'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('premium_admin_level_edit_form'),
    'access arguments' => array('administer premium content levels'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'premium.admin.inc',
  );

  $items['admin/content/premium/%premium_level/edit'] = array(
    'title' => t('Edit premium level'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('premium_admin_level_edit_form', 3),
    'access arguments' => array('administer premium content levels'),
    'type' => MENU_CALLBACK,
    'file' => 'premium.admin.inc',
  );

  $items['admin/content/premium/%premium_level/delete'] = array(
    'title' => t('Delete premium level'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('premium_admin_level_delete_form', 3),
    'access arguments' => array('administer premium content levels'),
    'type' => MENU_CALLBACK,
    'file' => 'premium.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_perm()
 */
function premium_perm() {
  $perms = array(
    'administer premium content levels',
    'administer node premium status',
  );

  foreach (premium_level_option_list() as $level_name) {
    $perms[] = _premium_permission_name($level_name);
  }

  return $perms;
}

/**
 * Implementation of hook_cron()
 */
function premium_cron() {
  $ts = $_SERVER['REQUEST_TIME'];

  // Clean out premium node data that has expired.
  db_query("DELETE FROM {premium_nodes} WHERE start_ts < %d AND end_ts <> 0 AND end_ts < %d", $ts, $ts);
}

/**
 * Implementation of hook_nodeapi()
 */
function premium_nodeapi(&$node, $op, $teaser) {
  switch ($op) {
    case 'load':
      $node->premium = premium_node_level($node);
      $node->premium_access = ($teaser) ? TRUE : premium_user_content_access($node);

      return array(
        'premium' => $node->premium,
        'premium_access' => $node->premium_access
      );
    case 'insert':
    case 'delete':
    case 'update':
      _premium_set_premium($node, $node->premium);
      break;
    case 'view':
      if (!$node->premium_access) {
        $node->content['body']['#value'] = theme('premium_body', $node);
      }
      break;
  }
}

/**
 * Implementation of hook_node_operations().
 */
function premium_node_operations() {
  $operations = array(
    'premium' => array(
      'label' => t('Set premium status'),
      'callback' => '_premium_node_operations_premium',
      'callback arguments' => array(1),
    ),
    'unpremium' => array(
      'label' => t('Remove premium status'),
      'callback' => '_premium_node_operations_premium',
      'callback arguments' => array(0),
    ),
  );
  return $operations;
}

/**
 * Callback for hook_node_operations()
 */
function _premium_node_operations_premium($nids, $premium = 0) {
  foreach ($nids as $nid) {
    $node = node_load($nid);
    _premium_set_premium($node, $premium);
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function premium_form_node_type_form_alter(&$form, &$form_state) {
  $node_type = $form['#node_type']->type;

  $form['workflow']['premium'] = array(
    '#type' => 'select',
    '#title' => t('Default premium content level'),
    '#default_value' => variable_get("premium_{$node_type}", 0),
    '#options' => array(0 => t('None')) + premium_level_option_list(),
  );
}

/**
 * Implementation of hook_form_alter()
 *
 * Add the Premium checkbox to the node editing options and default settings
 * The Premium flag will behave like other options (published, promote, etc).
 */
function premium_form_alter(&$form, $form_state, $form_id) {
  if ($form['#id'] == 'node-form') {
    $type = $form['type']['#value'];

    if (user_access('administer node premium status')) {
      $node = $form['#node'];
      $form['options']['premium'] = array(
        '#type' => 'select',
        '#title' => t('Premium content level'),
        '#default_value' => premium_node_level($node),
        '#options' => array(0 => t('None')) + premium_level_option_list(),
      );
    }
  }
}

/**
 * Implementation of hook_ctools_plugin_api().
 */
function premium_ctools_plugin_api($owner, $api) {
  if ($owner == 'premium' && $api == 'default_premium_levels') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function premium_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'access') {
    return 'plugins/' . $plugin;
  }
}


/**
 * Load a premium level based on machine name.
 *
 * @param $machine_name
 *   The machine name of the premium level to load.
 */
function premium_level_load($machine_name) {
  ctools_include('export');
  $result = ctools_export_load_object('premium_levels', 'names', array($machine_name));
  if (isset($result[$machine_name])) {
    return $result[$machine_name];
  }

  return FALSE;
}

/**
 * Get a list of premium levels keyed by machine name.
 */
function premium_level_load_all() {
  ctools_include('export');
  return ctools_export_load_object('premium_levels');
}

/**
 * Get a list of premium level names as an machine name-keyed array.
 *
 * Useful for selection menus, etc.
 */
function premium_level_option_list() {
  $levels = array();

  foreach (premium_level_load_all() as $machine_name => $level) {
    $levels[$machine_name] = $level->name;
  }

  return $levels;
}

/**
 * Inserts a new record, or updates an existing one.
 *
 * @param $level
 *   A level to be saved. If $level->level_id is set, the level will be updated.
 *   Otherwise, a new level will be inserted into the database.
 * @return
 *   The saved level, with its level_id set.
 */
function premium_level_save(&$level) {
  $update = (isset($level->level_id)) ? array('level_id') : array();

  return drupal_write_record('premium_levels', $level, $update);
}

/**
 * Deletes a record, given its unique ID.
 *
 * @param $record_id
 *   An int containing the ID of a record.
 */
function premium_level_delete($machine_name) {
  db_query("DELETE FROM {premium_levels} WHERE machine_name = '%d'", $machine_name);
  db_query("DELETE FROM {premium_nodes} WHERE machine_name = '%d'", $machine_name);
}

/**
 * Calculate time offset for auto-aging / auto-archiving
 */
function _premium_offset($timestamp, &$start_ts, &$end_ts, $mode, $count, $unit) {

  // If the timestamp is zero, set it to "now" so mktime() will work properly.
  $ts = $timestamp ? $timestamp : $_SERVER['REQUEST_TIME'];
  $offset = mktime(
    date('H', $ts) + ($unit=='H') * $count, 0, 0,
    date('m', $ts) + ($unit=='M') * $count,
    date('d', $ts) + ($unit=='D') * $count + ($unit == 'W') * $count * 7,
    date('y', $ts) + ($unit=='Y') * $count
  );

  // If we faked a timestamp, remove it.
  if ($ts != $timestamp) { $offset -= $ts; }

  if ($mode == 'archive') { $start_ts = $offset; }
  if ($mode == 'latest') { $end_ts = $offset; }
}

/**
 * Get premium level for a node.
 */
function premium_node_level($node) {
  // This is a node type: use default settings
  if (is_string($node)) {
    return variable_get("premium_{$node}", 0);
  }

  // Already has a value.
  if (isset($node->premium)) {
    return $node->premium;
  }

  if ($node->nid) {
    // Attempt to find the value from the premium table.
    $query = db_query("
      SELECT level_name FROM {premium_nodes} WHERE nid = %d
    ", array(':nid' => $node->nid));

    return db_result($query);
  }

  // Use default settings for this node type.
  return variable_get("premium_{$node->type}", 0);
}

/**
 * Determines if a user has access to premium content.
 *
 * @param $node
 *   The node object access is requested for.
 * @param $account
 *   The user to determine access for.
 * @return
 *   TRUE if access is granted, FALSE if not.
 */
function premium_user_content_access($node, $account = NULL) {
  global $user;

  // Fall back to the current user if none was provided.
  if (!$account) {
    $account = $user;
  }

  // If we're determining access for the current user, reuse the
  // premium_access on the node if present, since that is the result of
  // this function.
  if ($account == $user && isset($node->premium_access)) {
    return $node->premium_access;
  }

  // Access is granted or revoked explicitly.
  foreach (module_implements('premium_access') as $name) {
    $function = $name .'_premium_access';
    if (is_bool($access = $function($node, $teaser))) {
      return $access;
    }
  }

  // If node is not premium, always grant access.
  if (!$node->premium) {
    return TRUE;
  }

  // If node is premium, check if user has access to the level specified.
  if ($node->premium) {
    $level = premium_level_load($node->premium);
    return user_access(_premium_permission_name($level->name));
  }

  // Nobody said we could access the node.
  return FALSE;
}

/**
 * Establish premium visibility settings for a node.
 *
 * This function is deprecated, and is only kept for backwards compatibility.
 * We never restrict access to node teasers, so having it as a parameter
 * is kinda useless. Please use premium_user_content_access instead.
 *
 * @param $node
 *   The node object access is requested for.
 * @param $teaser
 *   TRUE if the node is being viewed in teaser mode (no access restrictions).
 * @return
 *   TRUE if access is granted, FALSE if not.
 */
function _premium_access($node, $teaser) {
  if ($teaser) {
    return TRUE;
  }

  return premium_user_content_access($node);
}

/**
 * Update the premium table with appropriate premium values for a node.
 */
function _premium_set_premium($node, $machine_name = FALSE) {
  db_query('DELETE FROM {premium_nodes} WHERE nid = %d', $node->nid);
  if ($machine_name) {
    $level = premium_level_load($machine_name);

    $start_ts = $end_ts = 0 ;
    _premium_offset($node->created, $start_ts, $end_ts, $level->proctection_type, $level->duration, $level->duration_unit);
    db_query("
      INSERT INTO {premium_nodes} (nid, level_name, start_ts, end_ts)
      VALUES (%d, '%s', %d, %d)
    ", array(
      ':nid' => $node->nid,
      ':machine_name' => $level->machine_name,
      ':start' => $start_ts,
      ':end' => $end_ts,
    ));
  }
}

/**
 * Helper function to generate permission name.
 */
function _premium_permission_name($level_name) {
  return 'access “' . check_plain($level_name) . '” premium content';
}

/**
 * Implementation of hook_theme().
 */
function premium_theme() {
  return array(
    'premium_body' => array(
      'arguments' => array('node' => NULL),
    ),
  );
}

/**
 * Reformat the message body with a premium content message
 */
function theme_premium_body($node) {
  return check_markup($node->teaser, $node->format, FALSE) .'<div class="premium-message">'. check_markup(variable_get('premium_message', t('Full text available to premium subscribers only')), variable_get('premium_format', FILTER_FORMAT_DEFAULT), FALSE) .'</div>';
}

